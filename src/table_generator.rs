#![allow(dead_code)]

mod bitboard;
mod board;

// Defines a relative move in the format of (rank, file)
type Move = (i8, i8);

// ------------- ALL MOVES TO GENERATE THE TABLE -------------

#[rustfmt::skip]
const KING_MOVES: [Move; 8] = [
    ( 1, -1), ( 1, 0), ( 1, 1),
    ( 0, -1),          ( 0, 1),
    (-1, -1), (-1, 0), (-1, 1),
];

const WHITE_PAWN_MOVE: [Move; 1] = [(1, 0)];
const BLACK_PAWN_MOVE: [Move; 1] = [(-1, 0)];

const WHITE_PAWN_ATTACKS: [Move; 2] = [(1, -1), (1, 1)];
const BLACK_PAWN_ATTACKS: [Move; 2] = [(-1, -1), (-1, 1)];

#[rustfmt::skip]
const KNIGHTS_MOVES: [Move; 8] = [
    ( 2, -1), ( 2, 1),
    ( 1, -2), ( 1, 2),
    (-1, -2), (-1, 2),
    (-2, -1), (-2, 1),
];

// ------------- STUFF TO MAKE THE SLIDING PIECES WORK -------------

// Actually just the same as the King moves
#[rustfmt::skip]
const RAY_MOVES: [Move; 8] = [
    ( 1, -1), ( 1, 0), ( 1, 1),
    ( 0, -1),          ( 0, 1),
    (-1, -1), (-1, 0), (-1, 1),
];

// -------------                                       -------------

fn main() {
    println!("// This file was auto generated by src/table_generator.rs!");
    println!("// Do not modify this file unless you are pretty clear about what you are doing.");
    println!();

    // PAWN MOVES

    println!("#[rustfmt::skip]");
    print!("pub const PAWN_PUSHES: [[u64; 64]; 2] = [[");
    let black_pawn_moves = generate_moves(&BLACK_PAWN_MOVE);
    for (index, bits) in black_pawn_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    print!("\n], [");
    let white_pawn_moves = generate_moves(&WHITE_PAWN_MOVE);
    for (index, bits) in white_pawn_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    println!("\n]];");

    // PAWN ATTACKS
    println!();

    println!("#[rustfmt::skip]");
    print!("pub const PAWN_ATTACKS: [[u64; 64]; 2] = [[");
    let black_pawn_moves = generate_moves(&BLACK_PAWN_ATTACKS);
    for (index, bits) in black_pawn_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    print!("\n], [");
    let white_pawn_moves = generate_moves(&WHITE_PAWN_ATTACKS);
    for (index, bits) in white_pawn_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    println!("\n]];");

    // KING MOVES
    println!();

    println!("#[rustfmt::skip]");
    print!("pub const KING_MOVES: [u64; 64] = [");
    let king_moves = generate_moves(&KING_MOVES);
    for (index, bits) in king_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    print!("\n];");

    // KNIGHT MOVES
    println!();

    println!("#[rustfmt::skip]");
    print!("pub const KNIGHT_MOVES: [u64; 64] = [");
    let knight_moves = generate_moves(&KNIGHTS_MOVES);
    for (index, bits) in knight_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    print!("\n];");
}

fn generate_moves(mask: &[Move]) -> [u64; 64] {
    let mut moves = [0u64; 64];

    for rank in 0..8 {
        for file in 0..8 {
            let index = ((8 * rank) + file) as usize;

            for (d_rank, d_file) in mask {
                let rank = rank as i8 + d_rank;
                let file = file as i8 + d_file;
                if !inside_board(rank, file) {
                    continue;
                }

                let d_index = ((8 * rank) + file) as usize;
                moves[index] |= 1u64 << d_index;
            }
        }
    }

    moves
}

fn generate_rays() -> [[u64; 8]; 64] {
    let mut rays = [[0u64; 8]; 64];

    for rank in 0..8 {
        for file in 0..8 {
            let index = ((8 * rank) + file) as usize;

            for (ray_index, (d_rank, d_file)) in RAY_MOVES.iter().enumerate() {
                let mut rank = rank as i8 + d_rank;
                let mut file = file as i8 + d_file;

                while inside_board(rank, file) {
                    let d_index = ((8 * rank) + file) as usize;
                    rays[index][ray_index] |= 1u64 << d_index;

                    rank += d_rank;
                    file += d_file;
                }
            }
        }
    }

    rays
}

fn inside_board(rank: i8, file: i8) -> bool {
    (rank >= 0 && rank <= 7) && (file >= 0 && file <= 7)
}
