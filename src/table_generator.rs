#![allow(dead_code)]

// Defines a relative move in the format of (rank, file)
type Move = (i8, i8);

// ------------- ALL MOVES TO GENERATE THE TABLE -------------

#[rustfmt::skip]
const KING_MOVES: [Move; 8] = [
    ( 1, -1), ( 1, 0), ( 1, 1),
    ( 0, -1),          ( 0, 1),
    (-1, -1), (-1, 0), (-1, 1),
];

const WHITE_PAWN_MOVE: [Move; 1] = [(1, 0)];
const BLACK_PAWN_MOVE: [Move; 1] = [(-1, 0)];

const WHITE_PAWN_ATTACKS: [Move; 2] = [(1, -1), (1, 1)];
const BLACK_PAWN_ATTACKS: [Move; 2] = [(-1, -1), (-1, 1)];

#[rustfmt::skip]
const KNIGHTS_MOVES: [Move; 8] = [
    ( 2, -1), ( 2, 1),
    ( 1, -2), ( 1, 2),
    (-1, -2), (-1, 2),
    (-2, -1), (-2, 1),
];

// ------------- STUFF TO MAKE THE SLIDING PIECES WORK -------------

// Actually just the same as the King moves
#[rustfmt::skip]
const RAY_MOVES: [Move; 8] = [
    ( 1, -1), ( 1, 0), ( 1, 1),
    ( 0, -1),          ( 0, 1),
    (-1, -1), (-1, 0), (-1, 1),
];

const FILE_0: u64 = 0x101010101010101;
const FILE_7: u64 = 0x8080808080808080;

const RANK_0: u64 = 0xff;
const RANK_7: u64 = 0xff00000000000000;

// -------------                                       -------------

fn main() {
    println!("// This file was auto generated by src/table_generator.rs!");
    println!("// Do not modify this file unless you are pretty clear about what you are doing.");

    // PAWN MOVES
    println!();

    println!("#[rustfmt::skip]");
    print!("pub const PAWN_PUSHES: [[u64; 64]; 2] = [[");
    let black_pawn_moves = generate_moves(&BLACK_PAWN_MOVE);
    for (index, bits) in black_pawn_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    print!("\n], [");
    let white_pawn_moves = generate_moves(&WHITE_PAWN_MOVE);
    for (index, bits) in white_pawn_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    println!("\n]];");

    // PAWN ATTACKS
    println!();

    println!("#[rustfmt::skip]");
    print!("pub const PAWN_ATTACKS: [[u64; 64]; 2] = [[");
    let black_pawn_moves = generate_moves(&BLACK_PAWN_ATTACKS);
    for (index, bits) in black_pawn_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    print!("\n], [");
    let white_pawn_moves = generate_moves(&WHITE_PAWN_ATTACKS);
    for (index, bits) in white_pawn_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    println!("\n]];");

    // KING MOVES
    println!();

    println!("#[rustfmt::skip]");
    print!("pub const KING_MOVES: [u64; 64] = [");
    let king_moves = generate_moves(&KING_MOVES);
    for (index, bits) in king_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    println!("\n];");

    // KNIGHT MOVES
    println!();

    println!("#[rustfmt::skip]");
    print!("pub const KNIGHT_MOVES: [u64; 64] = [");
    let knight_moves = generate_moves(&KNIGHTS_MOVES);
    for (index, bits) in knight_moves.iter().enumerate() {
        if index % 8 == 0 {
            print!("\n\t");
        }
        print!("0x{:x}, ", bits);
    }
    println!("\n];");

    // RAYS
    println!();
    
    let rays = generate_rays();
    
    println!("#[rustfmt::skip]");
    println!("pub const RAYS: [[u64; 8]; 64] = [");
    for index in 0..64 {
        print!("\t[ ");
        for ray in &rays[index] {
            print!("0x{:x}, ", ray);
        }
        println!("],");
    }
    println!("];");

    // let occupancies = generate_rook_occupancies(&rays);
    // let blockers = get_blockers(occupancies);
    // println!("{} {}", blockers.len(), blockers.get(0).unwrap().len());
}

fn generate_moves(mask: &[Move]) -> [u64; 64] {
    let mut moves = [0u64; 64];

    for rank in 0..8 {
        for file in 0..8 {
            let index = ((8 * rank) + file) as usize;

            for (d_rank, d_file) in mask {
                let rank = rank as i8 + d_rank;
                let file = file as i8 + d_file;
                if !inside_board(rank, file) {
                    continue;
                }

                let d_index = ((8 * rank) + file) as usize;
                moves[index] |= 1u64 << d_index;
            }
        }
    }

    moves
}

fn generate_rays() -> [[u64; 8]; 64] {
    let mut rays = [[0u64; 8]; 64];

    for rank in 0..8 {
        for file in 0..8 {
            let index = ((8 * rank) + file) as usize;

            for (ray_index, (d_rank, d_file)) in RAY_MOVES.iter().enumerate() {
                let mut rank = rank as i8 + d_rank;
                let mut file = file as i8 + d_file;

                while inside_board(rank, file) {
                    let d_index = ((8 * rank) + file) as usize;
                    rays[index][ray_index] |= 1u64 << d_index;

                    rank += d_rank;
                    file += d_file;
                }
            }
        }
    }

    rays
}

// fn generate_rook_occupancies(rays: &[[u64; 8]; 64]) -> [u64; 64] {
//     let mut rook_occupancies = [0u64; 64];

//     for rank in 0..8 {
//         for file in 0..8 {
//             let index = ((8 * rank) + file) as usize;

//             let ray_north = rays[index][1];
//             let ray_west = rays[index][3];
//             let ray_east = rays[index][4];
//             let ray_south = rays[index][6];

//             let mut all_rays = ray_north | ray_east | ray_south | ray_west;
//             if rank > 0 {
//                 all_rays ^= all_rays & RANK_0;
//             }
//             if rank < 7 {
//                 all_rays ^= all_rays & RANK_7;
//             }
//             if file > 0 {
//                 all_rays ^= all_rays & FILE_0;
//             }
//             if file < 7 {
//                 all_rays ^= all_rays & FILE_7;
//             }

//             rook_occupancies[index] = all_rays;
//         }
//     }

//     rook_occupancies
// }

// fn get_blockers(occupancies: [u64; 64]) -> Vec<Vec<u64>> {
//     let mut blockers: Vec<Vec<u64>> = Vec::new();

//     for occupancy in occupancies {
//         let combinations = get_combinations(occupancy);
//         blockers.push(combinations);
//     }

//     blockers
// }

// fn get_combinations(mut number: u64) -> Vec<u64> {
//     let mut masks = Vec::new();
//     loop {
//         if number == 0 {
//             break;
//         }

//         let index = 63 - number.leading_zeros();
//         let mask = 1u64 << index;
//         masks.push(mask);
//         number ^= mask;
//     }

//     let mut combinations = Vec::new();
//     all_combinations(&mut combinations, 0, masks.as_slice(), 0, masks.len());

//     combinations
// }

// fn all_combinations(
//     combinations: &mut Vec<u64>,
//     number: u64,
//     masks: &[u64],
//     index: usize,
//     n: usize,
// ) {
//     if index == n {
//         combinations.push(number);
//         return;

//     }

//     all_combinations(combinations, number, masks, index + 1, n);

//     let masked_number = number ^ masks[index];
//     all_combinations(combinations, masked_number, masks, index + 1, n);
// }

fn inside_board(rank: i8, file: i8) -> bool {
    (rank >= 0 && rank <= 7) && (file >= 0 && file <= 7)
}
